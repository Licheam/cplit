pub mod cplit {  pub mod data_structure {  pub mod binary_indexed_tree { #[derive(Debug)] pub struct BinaryIndexedTree { b: Vec<isize>, n: usize, }  impl BinaryIndexedTree { pub fn new(n: usize) -> Self { Self { b: vec![0; n + 1], n, } }  fn lowbit(x: usize) -> usize { x & (!x + 1) }  pub fn change(&mut self, mut x: usize, y: isize) { let BinaryIndexedTree { b, n } = self; while x <= *n { b[x] += y; x += Self::lowbit(x); } }  pub fn sum(&self, mut x: usize) -> isize { let BinaryIndexedTree { b, .. } = &self; let mut s: isize = 0; while x > 0 { s += b[x]; x -= Self::lowbit(x); } s }  pub fn build(&mut self, a: &Vec<isize>) { let BinaryIndexedTree { b, n } = self; for i in 1..=*n { b[i] = a[i - 1]; } let mut x = 1; while x << 1 <= *n { for i in (x..=*n - x).step_by(x << 1) { b[i + x] += b[i]; } x <<= 1; } } } } pub mod disjoint_set_union {  #[derive(Debug)] pub struct DisjointSetUnion { fa: Vec<usize>, }  impl DisjointSetUnion { pub fn new(n: usize) -> Self { let fa = (0..=n).collect(); DisjointSetUnion { fa } }  pub fn find(&mut self, x: usize) -> usize { if self.fa[x] == x { x } else { self.fa[x] = self.find(self.fa[x]); self.fa[x] } }  pub fn join(&mut self, x: usize, y: usize) { let fx = self.find(x); self.fa[fx] = self.find(y); } } } pub mod segment_tree { #[derive(Debug)] pub struct SegmentTree { sum: Vec<i64>, tag: Vec<i64>, }  impl SegmentTree { pub fn new(n: usize) -> Self { Self { sum: vec![0; n << 2], tag: vec![0; n << 2], } }  fn pushup(&mut self, x: usize) { let SegmentTree { sum, .. } = self; sum[x] = sum[x << 1] + sum[x << 1 | 1]; }  fn pushdown(&mut self, x: usize, l: usize, r: usize) { let SegmentTree { sum, tag } = self; let m = (l + r) >> 1; sum[x << 1] += tag[x] * (m - l + 1) as i64; tag[x << 1] += tag[x]; sum[x << 1 | 1] += tag[x] * (r - m) as i64; tag[x << 1 | 1] += tag[x]; tag[x] = 0; }  pub fn build(&mut self, x: usize, l: usize, r: usize, a: &Vec<i64>) { let SegmentTree { sum, .. } = self; if l == r { sum[x] = a[l - 1] } else { let m = (l + r) >> 1; self.build(x << 1, l, m, a); self.build(x << 1 | 1, m + 1, r, a); self.pushup(x); } }  pub fn modify(&mut self, x: usize, l: usize, r: usize, ql: usize, qr: usize, del: i64) { if ql <= l && r <= qr { let SegmentTree { sum, tag } = self; sum[x] += del * (r - l + 1) as i64; tag[x] += del; } else { self.pushdown(x, l, r); let m = (l + r) >> 1; if ql <= m { self.modify(x << 1, l, m, ql, qr, del) } if m < qr { self.modify(x << 1 | 1, m + 1, r, ql, qr, del) } self.pushup(x); } }  pub fn query(&mut self, x: usize, l: usize, r: usize, ql: usize, qr: usize) -> i64 { if ql <= l && r <= qr { self.sum[x] } else { self.pushdown(x, l, r); let m = (l + r) >> 1; (if ql <= m { self.query(x << 1, l, m, ql, qr) } else { 0 }) + (if m < qr { self.query(x << 1 | 1, m + 1, r, ql, qr) } else { 0 }) } } } }  #[doc(inline)] pub use self::binary_indexed_tree::BinaryIndexedTree; #[doc(inline)] pub use self::disjoint_set_union::DisjointSetUnion; #[doc(inline)] pub use self::segment_tree::SegmentTree; } pub mod graph { pub struct Graph<V, E> where V: Default + Clone, E: Clone, { pub nodes: Vec<V>, pub edges: Vec<Vec<(usize, E)>>, }  impl<V, E> Graph<V, E> where V: Default + Clone, E: Clone, { pub fn new(n: usize) -> Self { Self { nodes: vec![V::default(); n + 1], edges: vec![vec![]; n + 1], } }  pub fn add_edge(&mut self, from: usize, to: usize, edge: E) { self.edges[from].push((to, edge)); } }  pub mod dijkstra { use super::Distance; use crate::num::{bounds::UpperBounded, Numeric, NumericAssOps, NumericCmpOps, NumericOps}; use std::cmp::Reverse; use std::collections::BinaryHeap;  pub fn dijkstra<V, E, N>(source: usize, graph: &super::Graph<V, E>) -> Vec<N> where N: Numeric + UpperBounded + NumericOps + NumericCmpOps + NumericAssOps, V: Default + Clone, E: Clone + Distance<N>, { let n = graph.nodes.len() - 1; let mut dist = vec![N::MAX; n + 1]; let mut visited = vec![false; n + 1]; dist[source] = N::ZERO; let mut pq = BinaryHeap::new(); pq.push((Reverse(N::ZERO), source)); while let Some((_, u)) = pq.pop() { if visited[u] { continue; } visited[u] = true; for (v, e) in &graph.edges[u] { if dist[*v] > dist[u] + e.dist() { dist[*v] = dist[u] + e.dist(); pq.push((Reverse(dist[*v]), *v)); } } } dist } } pub mod distance { use crate::num::Numeric; pub trait Distance<T> where T: Numeric, { fn dist(&self) -> T; }  impl<T> Distance<T> for T where T: Numeric, { fn dist(&self) -> T { *self } } } pub use self::dijkstra::dijkstra; pub use self::distance::Distance; } mod io { #[macro_use] mod macros { #[macro_export] macro_rules! scanln { ($($i:expr), +) => { fscanln!(std::io::stdin(), $($i), +); };  ($coll:expr ; $n:expr) => { fscanln!(std::io::stdin(), $coll ; $n); };  ($coll:expr ;) => { fscanln!(std::io::stdin(), $coll ;); }; }  #[macro_export] macro_rules! fscanln { ($reader:expr, $($i:expr), +) => { use std::io::BufRead; let mut iter = std::iter::repeat_with(|| { let mut buf = String::new(); $reader.read_line(&mut buf).unwrap(); buf.split_whitespace() .map(|x| x.parse().unwrap()) .collect::<Vec<_>>() }) .flatten(); $( $i = iter.next().unwrap(); )* };  ($reader:expr, $coll:expr ; $n:expr) => { use std::io::BufRead; $coll = std::iter::once(Default::default()) .chain( std::iter::repeat_with(|| { let mut buf = String::new(); $reader.read_line(&mut buf).unwrap(); buf.split_whitespace() .map(|x| x.parse().unwrap()) .collect::<Vec<_>>() }) .flatten() .take($n), ) .collect(); };  ($reader:expr, $coll:expr ;) => { use std::io::BufRead; let mut buf = String::new(); $reader.read_line(&mut buf).unwrap(); $coll = std::iter::once(Default::default()) .chain(buf.split_whitespace().map(|x| x.parse().unwrap())) .collect(); }; } } } pub mod num { use core::cmp::{Eq, Ord, PartialEq, PartialOrd}; use core::ops::{Add, Div, Mul, Rem, Sub}; use core::ops::{AddAssign, DivAssign, MulAssign, RemAssign, SubAssign}; pub mod bounds { pub trait LowerBounded { const MIN: Self; }  pub trait UpperBounded { const MAX: Self; }  pub trait Bounded: LowerBounded + UpperBounded {}  macro_rules! bounded_trait_impl { ($t:ty, $min:expr, $max:expr) => { impl LowerBounded for $t { const MIN: Self = $min; }  impl UpperBounded for $t { const MAX: Self = $max; } }; }  bounded_trait_impl!(usize, usize::MIN, usize::MAX); bounded_trait_impl!(u8, u8::MIN, u8::MAX); bounded_trait_impl!(u16, u16::MIN, u16::MAX); bounded_trait_impl!(u32, u32::MIN, u32::MAX); bounded_trait_impl!(u64, u64::MIN, u64::MAX); bounded_trait_impl!(u128, u128::MIN, u128::MAX);  bounded_trait_impl!(isize, isize::MIN, isize::MAX); bounded_trait_impl!(i8, i8::MIN, i8::MAX); bounded_trait_impl!(i16, i16::MIN, i16::MAX); bounded_trait_impl!(i32, i32::MIN, i32::MAX); bounded_trait_impl!(i64, i64::MIN, i64::MAX); bounded_trait_impl!(i128, i128::MIN, i128::MAX);  bounded_trait_impl!(f32, f32::MIN, f32::MAX); bounded_trait_impl!(f64, f64::MIN, f64::MAX); }  pub trait Numeric: Default + Copy + Clone + PartialEq + Zero + One {}  impl<T> Numeric for T where T: Default + Copy + Clone + PartialEq + Zero + One {}  pub trait NumericOps<Rhs = Self, Output = Self>: Add<Rhs, Output = Output> + Sub<Rhs, Output = Output> + Mul<Rhs, Output = Output> + Div<Rhs, Output = Output> + Rem<Rhs, Output = Output> { }  impl<T, Rhs, Output> NumericOps<Rhs, Output> for T where T: Add<Rhs, Output = Output> + Sub<Rhs, Output = Output> + Mul<Rhs, Output = Output> + Div<Rhs, Output = Output> + Rem<Rhs, Output = Output> { }  pub trait NumericAssOps<Rhs = Self>: AddAssign<Rhs> + SubAssign<Rhs> + MulAssign<Rhs> + DivAssign<Rhs> + RemAssign<Rhs> { }  impl<T, Rhs> NumericAssOps<Rhs> for T where T: AddAssign<Rhs> + SubAssign<Rhs> + MulAssign<Rhs> + DivAssign<Rhs> + RemAssign<Rhs> { }  pub trait NumericCmpOps<Rhs = Self>: PartialEq<Rhs> + PartialOrd<Rhs> + Eq + Ord {}  impl<T, Rhs> NumericCmpOps<Rhs> for T where T: PartialEq<Rhs> + PartialOrd<Rhs> + Eq + Ord {}  pub trait Zero { const ZERO: Self; }  pub trait One { const ONE: Self; }  macro_rules! zero_trait_impl { ($name:ident for $($t:ty)*) => ($( impl $name for $t { const ZERO: Self = 0 as $t; } )*) }  zero_trait_impl!(Zero for usize u8 u16 u32 u64 u128); zero_trait_impl!(Zero for isize i8 i16 i32 i64 i128); zero_trait_impl!(Zero for f32 f64);  macro_rules! one_trait_impl { ($name:ident for $($t:ty)*) => ($( impl $name for $t { const ONE: Self = 1 as $t; } )*) }  one_trait_impl!(One for usize u8 u16 u32 u64 u128); one_trait_impl!(One for isize i8 i16 i32 i64 i128); one_trait_impl!(One for f32 f64); } }

