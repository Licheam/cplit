pub mod cplit { #![allow(clippy::needless_doctest_main)]  pub mod general { pub mod binary_search { use crate::cplit::num::{Bounded, Numeric, NumericCmpOps, NumericOps}; use std::ops::{Bound, RangeBounds};  pub fn binary_search<N>(bounds: impl RangeBounds<N>, f: impl Fn(N) -> bool) -> N where N: Numeric + NumericOps + NumericCmpOps + Copy + Clone + Bounded, { let mut left = match bounds.start_bound() { Bound::Included(&s) => s, Bound::Excluded(&s) => s + N::ONE, Bound::Unbounded => N::MIN, }; let mut right = match bounds.end_bound() { Bound::Included(&e) => e + N::ONE, Bound::Excluded(&e) => e, Bound::Unbounded => N::MAX, };  while left < right { let mid = (left + right) / (N::ONE + N::ONE); if f(mid) { right = mid; } else { left = mid + N::ONE; } }  left } } #[doc(inline)] pub use self::binary_search::binary_search; } pub mod data_structure {  pub mod binary_indexed_tree { use crate::cplit::num::{Numeric, NumericAssOps, NumericOps}; use std::ops::{Bound, RangeBounds}; use std::vec;  macro_rules! low_bit { ($index: expr) => { ($index & (!$index + 1)) }; }  #[derive(Debug)] pub struct BinaryIndexedTree<N> where N: Numeric + NumericOps + NumericAssOps + Clone + Copy, { body: Vec<N>, }  impl<N> BinaryIndexedTree<N> where N: Numeric + NumericOps + NumericAssOps + Clone + Copy, { pub fn new() -> Self { Self { body: vec![N::ZERO], } }  pub fn with_capacity(capacity: usize) -> Self { let mut body = Vec::with_capacity(capacity + 1); body.push(N::ZERO); Self { body } }  pub fn len(&self) -> usize { self.body.len() - 1 }  pub fn is_empty(&self) -> bool { self.len() == 0 }  pub fn add(&mut self, mut index: usize, delta: N) { if !(1..=self.len()).contains(&index) { panic!( "Index out of bounds: the range is 1..={} but the index is {}", self.len(), index ); } while index <= self.len() { self.body[index] += delta; index += low_bit!(index); } }  pub fn sum(&self, bounds: impl RangeBounds<usize>) -> N { let mut start = match bounds.start_bound() { Bound::Included(&s) => s, Bound::Excluded(&s) => s + 1, Bound::Unbounded => 1, }; let mut end = match bounds.end_bound() { Bound::Included(&e) => e + 1, Bound::Excluded(&e) => e, Bound::Unbounded => self.len() + 1, };  if !(1..=self.len() + 1).contains(&start) || !(1..=self.len() + 1).contains(&end) { panic!( "Query out of bounds: the range is 1..={} but the query is {}..{}", self.len(), start, end, ); } if start >= end { return N::ZERO; }  start -= 1; end -= 1;  let mut s = N::ZERO; while end > start { s += self.body[end]; end -= low_bit!(end); } while start > end { s -= self.body[start]; start -= low_bit!(start); } s }  pub fn push(&mut self, value: N) { let len = self.len() + 1; let sum = self.sum(len - low_bit!(len) + 1..len); self.body.push(value + sum); }  pub fn pop(&mut self) -> Option<N> { self.body.pop() }  fn init(&mut self) { for i in 1..=self.len() { let j = i + low_bit!(i); if j <= self.len() { let t = self.body[i]; self.body[j] += t; } } } }  impl<N, T> From<T> for BinaryIndexedTree<N> where N: Numeric + NumericOps + NumericAssOps + Clone + Copy, T: Into<Vec<N>>, { fn from(a: T) -> Self { let mut bit = BinaryIndexedTree { body: a.into() }; bit.init(); bit } }  impl<N> Default for BinaryIndexedTree<N> where N: Numeric + NumericOps + NumericAssOps + Clone + Copy, { fn default() -> Self { Self::new() } } } pub mod disjoint_set_union { #[derive(Debug)] pub struct DisjointSetUnion { parent: Vec<usize>, }  impl DisjointSetUnion { pub fn with_len(len: usize) -> Self { DisjointSetUnion { parent: (0..=len).collect(), } }  pub fn len(&self) -> usize { self.parent.len() - 1 }  pub fn is_empty(&self) -> bool { self.len() == 0 }  pub fn find(&mut self, x: usize) -> usize { if self.parent[x] == x { x } else { self.parent[x] = self.find(self.parent[x]); self.parent[x] } }  pub fn union(&mut self, x: usize, y: usize) { let fx = self.find(x); self.parent[fx] = self.find(y); } }  impl<T> From<T> for DisjointSetUnion where T: Into<Vec<usize>>, { fn from(a: T) -> Self { DisjointSetUnion { parent: a.into() } } } } pub mod segment_tree { pub mod ops { use crate::cplit::num::{Numeric, NumericOps}; use std::convert::TryFrom; use std::fmt::Debug; use std::marker::PhantomData;  pub trait Operation<V, T> where V: Clone + Copy, T: Clone + Copy, { const COMBINE: fn(left_val: V, right_val: V) -> V;  const PUSH_VAL: fn(val: V, tag: T, len: usize) -> V;  const PUSH_TAG: fn(child_tag: T, tag: T) -> T;  const VAL_IDENTITY: V;  const TAG_IDENTITY: T; }  #[derive(Debug)] pub struct AddSum;  impl<V> Operation<V, V> for AddSum where V: Numeric + NumericOps + Clone + Copy + TryFrom<usize>, <V as TryFrom<usize>>::Error: Debug, { const COMBINE: fn(V, V) -> V = |left_val, right_val| left_val + right_val; const PUSH_VAL: fn(V, V, usize) -> V = |val, tag, len| val + tag * V::try_from(len).unwrap(); const PUSH_TAG: fn(V, V) -> V = |child_tag, tag| child_tag + tag; const TAG_IDENTITY: V = V::ZERO; const VAL_IDENTITY: V = V::ZERO; }  pub struct OperationPair<V1, V2, T1, T2, O1, O2> where V1: Clone + Copy, V2: Clone + Copy, T1: Clone + Copy, T2: Clone + Copy, O1: Operation<V1, T1>, O2: Operation<V2, T2>, { _phantoms: ( PhantomData<V1>, PhantomData<V2>, PhantomData<T1>, PhantomData<T2>, PhantomData<O1>, PhantomData<O2>, ), }  impl<V1, V2, T1, T2, O1, O2> OperationPair<V1, V2, T1, T2, O1, O2> where V1: Clone + Copy, V2: Clone + Copy, T1: Clone + Copy, T2: Clone + Copy, O1: Operation<V1, T1>, O2: Operation<V2, T2>, { const COMBINE: fn(left_val: (V1, V2), right_val: (V1, V2)) -> (V1, V2) = |left_val, right_val| { ( O1::COMBINE(left_val.0, right_val.0), O2::COMBINE(left_val.1, right_val.1), ) };  const PUSH_VAL: fn((V1, V2), (T1, T2), usize) -> (V1, V2) = |val, tag, len| { ( O1::PUSH_VAL(val.0, tag.0, len), O2::PUSH_VAL(val.1, tag.1, len), ) };  const PUSH_TAG: fn((T1, T2), (T1, T2)) -> (T1, T2) = |child_tag, tag| { ( O1::PUSH_TAG(child_tag.0, tag.0), O2::PUSH_TAG(child_tag.1, tag.1), ) };  const TAG_IDENTITY: (T1, T2) = (O1::TAG_IDENTITY, O2::TAG_IDENTITY);  const VAL_IDENTITY: (V1, V2) = (O1::VAL_IDENTITY, O2::VAL_IDENTITY); } } #[doc(inline)] pub use self::ops::{AddSum, Operation, OperationPair};  use std::fmt::Debug; use std::marker::PhantomData;  #[derive(Debug)] pub struct SegmentTree<V, T, O> where V: Clone + Copy, T: Clone + Copy, O: Operation<V, T>, { val: Vec<V>, tag: Vec<T>, len: usize, phantom: PhantomData<O>, }  impl<V, T, O> SegmentTree<V, T, O> where V: Clone + Copy, T: Clone + Copy, O: Operation<V, T>, { pub fn len(&self) -> usize { self.len }  pub fn is_empty(&self) -> bool { self.len == 0 }  fn pushup(&mut self, x: usize) { self.val[x] = O::COMBINE(self.val[x << 1], self.val[x << 1 | 1]); }  fn pushdown(&mut self, x: usize, l: usize, r: usize) { let m = (l + r) >> 1; self.val[x << 1] = O::PUSH_VAL(self.val[x << 1], self.tag[x], m - l + 1); self.val[x << 1 | 1] = O::PUSH_VAL(self.val[x << 1 | 1], self.tag[x], r - m); self.tag[x << 1] = O::PUSH_TAG(self.tag[x << 1], self.tag[x]); self.tag[x << 1 | 1] = O::PUSH_TAG(self.tag[x << 1 | 1], self.tag[x]); self.tag[x] = O::TAG_IDENTITY; }  pub fn modify(&mut self, x: usize, l: usize, r: usize, ql: usize, qr: usize, delta: T) { if ql <= l && r <= qr { self.val[x] = O::PUSH_VAL(self.val[x], delta, r - l + 1); self.tag[x] = O::PUSH_TAG(self.tag[x], delta); } else { self.pushdown(x, l, r); let m = (l + r) >> 1; if ql <= m { self.modify(x << 1, l, m, ql, qr, delta) } if m < qr { self.modify(x << 1 | 1, m + 1, r, ql, qr, delta) } self.pushup(x); } }  pub fn query(&mut self, x: usize, l: usize, r: usize, ql: usize, qr: usize) -> V { if ql <= l && r <= qr { self.val[x] } else { self.pushdown(x, l, r); let m = (l + r) >> 1; O::COMBINE( if ql <= m { self.query(x << 1, l, m, ql, qr) } else { O::VAL_IDENTITY }, if m < qr { self.query(x << 1 | 1, m + 1, r, ql, qr) } else { O::VAL_IDENTITY }, ) } }  fn init(&mut self, x: usize, l: usize, r: usize, a: &Vec<V>) { if l == r { self.val[x] = a[l] } else { let m = (l + r) >> 1; self.init(x << 1, l, m, a); self.init(x << 1 | 1, m + 1, r, a); self.pushup(x); } } }  impl<V, T, O, Q> From<Q> for SegmentTree<V, T, O> where V: Clone + Copy, T: Clone + Copy, O: Operation<V, T>, Q: Into<Vec<V>>, { fn from(a: Q) -> Self { let v = a.into(); let len = v.len() - 1; let mut st = SegmentTree { val: vec![O::VAL_IDENTITY; 1 + (len << 2)], tag: vec![O::TAG_IDENTITY; 1 + (len << 2)], len, phantom: PhantomData, }; st.init(1, 1, len, &v); st } } }  #[doc(inline)] pub use self::binary_indexed_tree::BinaryIndexedTree; #[doc(inline)] pub use self::disjoint_set_union::DisjointSetUnion; #[doc(inline)] pub use self::segment_tree::SegmentTree; } pub mod graph {  pub struct Graph<V, E> where V: Default + Clone, E: Clone, { pub nodes: Vec<V>, pub edges: Vec<Vec<(usize, E)>>, }  impl<V, E> Graph<V, E> where V: Default + Clone, E: Clone, { pub fn new(n: usize) -> Self { Self { nodes: vec![V::default(); n + 1], edges: vec![vec![]; n + 1], } }  pub fn add_edge(&mut self, from: usize, to: usize, edge: E) { self.edges[from].push((to, edge)); } }  pub mod dijkstra { use super::Distance; use crate::cplit::num::{Numeric, NumericAssOps, NumericCmpOps, NumericOps}; use std::cmp::Reverse; use std::collections::BinaryHeap;  pub fn dijkstra<V, E, N>(source: usize, graph: &super::Graph<V, E>) -> Vec<Option<N>> where N: Numeric + NumericOps + NumericCmpOps + NumericAssOps + Clone + Copy, V: Default + Clone, E: Clone + Distance<N>, { let n = graph.nodes.len() - 1; let mut dist = vec![None; n + 1]; let mut visited = vec![false; n + 1]; dist[source] = Some(N::ZERO); let mut pq = BinaryHeap::new(); pq.push((Reverse(N::ZERO), source)); while let Some((_, u)) = pq.pop() { if visited[u] { continue; } visited[u] = true; for (v, e) in &graph.edges[u] { if dist[*v].map_or(true, |distv| distv > dist[u].unwrap() + e.dist()) { dist[*v] = Some(dist[u].unwrap() + e.dist()); pq.push((Reverse(dist[*v].unwrap()), *v)); } } } dist } } pub mod distance { use crate::cplit::num::Numeric; pub trait Distance<N> where N: Numeric + Copy, { fn dist(&self) -> N; }  impl<N> Distance<N> for N where N: Numeric + Copy, { fn dist(&self) -> N { *self } } } #[doc(inline)] pub use self::dijkstra::dijkstra; #[doc(inline)] pub use self::distance::Distance; } pub mod num { use std::cmp::{Eq, Ord, PartialEq, PartialOrd}; use std::ops::{Add, Div, Mul, Rem, Sub}; use std::ops::{AddAssign, DivAssign, MulAssign, RemAssign, SubAssign}; pub mod bounds { pub trait LowerBounded { const MIN: Self; }  pub trait UpperBounded { const MAX: Self; }  pub trait Bounded: LowerBounded + UpperBounded {}  impl<T> Bounded for T where T: LowerBounded + UpperBounded {}  macro_rules! bounded_trait_impl { ($t:ty, $min:expr, $max:expr) => { impl LowerBounded for $t { const MIN: Self = $min; }  impl UpperBounded for $t { const MAX: Self = $max; } }; }  bounded_trait_impl!(usize, usize::MIN, usize::MAX); bounded_trait_impl!(u8, u8::MIN, u8::MAX); bounded_trait_impl!(u16, u16::MIN, u16::MAX); bounded_trait_impl!(u32, u32::MIN, u32::MAX); bounded_trait_impl!(u64, u64::MIN, u64::MAX); bounded_trait_impl!(u128, u128::MIN, u128::MAX);  bounded_trait_impl!(isize, isize::MIN, isize::MAX); bounded_trait_impl!(i8, i8::MIN, i8::MAX); bounded_trait_impl!(i16, i16::MIN, i16::MAX); bounded_trait_impl!(i32, i32::MIN, i32::MAX); bounded_trait_impl!(i64, i64::MIN, i64::MAX); bounded_trait_impl!(i128, i128::MIN, i128::MAX);  bounded_trait_impl!(f32, f32::MIN, f32::MAX); bounded_trait_impl!(f64, f64::MIN, f64::MAX); } #[doc(inline)] pub use self::bounds::{Bounded, LowerBounded, UpperBounded};  pub trait Numeric: Default + Zero + One {}  impl<T> Numeric for T where T: Default + Zero + One {}  pub trait NumericOps<Rhs = Self, Output = Self>: Add<Rhs, Output = Output> + Sub<Rhs, Output = Output> + Mul<Rhs, Output = Output> + Div<Rhs, Output = Output> { }  impl<T, Rhs, Output> NumericOps<Rhs, Output> for T where T: Add<Rhs, Output = Output> + Sub<Rhs, Output = Output> + Mul<Rhs, Output = Output> + Div<Rhs, Output = Output> { }  pub trait IntegerOps<Rhs = Self, Output = Self>: NumericOps<Rhs, Output> + Rem<Rhs, Output = Output> { }  impl<T, Rhs, Output> IntegerOps<Rhs, Output> for T where T: NumericOps<Rhs, Output> + Rem<Rhs, Output = Output> { }  pub trait NumericAssOps<Rhs = Self>: AddAssign<Rhs> + SubAssign<Rhs> + MulAssign<Rhs> + DivAssign<Rhs> { }  impl<T, Rhs> NumericAssOps<Rhs> for T where T: AddAssign<Rhs> + SubAssign<Rhs> + MulAssign<Rhs> + DivAssign<Rhs> { }  pub trait IntegerAssOps<Rhs = Self>: NumericAssOps<Rhs> + RemAssign<Rhs> {} impl<T, Rhs> IntegerAssOps<Rhs> for T where T: NumericAssOps<Rhs> + RemAssign<Rhs> {}  pub trait NumericCmpOps<Rhs = Self>: PartialEq<Rhs> + PartialOrd<Rhs> + Eq + Ord {}  impl<T, Rhs> NumericCmpOps<Rhs> for T where T: PartialEq<Rhs> + PartialOrd<Rhs> + Eq + Ord {}  pub trait Zero { const ZERO: Self; }  pub trait One { const ONE: Self; }  macro_rules! zero_trait_impl { ($name:ident for $($t:ty)*) => ($( impl $name for $t { const ZERO: Self = 0 as $t; } )*) }  zero_trait_impl!(Zero for usize u8 u16 u32 u64 u128); zero_trait_impl!(Zero for isize i8 i16 i32 i64 i128); zero_trait_impl!(Zero for f32 f64);  macro_rules! one_trait_impl { ($name:ident for $($t:ty)*) => ($( impl $name for $t { const ONE: Self = 1 as $t; } )*) }  one_trait_impl!(One for usize u8 u16 u32 u64 u128); one_trait_impl!(One for isize i8 i16 i32 i64 i128); one_trait_impl!(One for f32 f64);  macro_rules! tuple_zero_impl { ( $( $name:ident )+ ) => { impl<$($name: Zero),+> Zero for ($($name,)+) { const ZERO: Self = ($($name::ZERO,)+); } }; }  tuple_zero_impl!(A B);  macro_rules! tuple_one_impl { ( $( $name:ident )+ ) => { impl<$($name: One),+> One for ($($name,)+) { const ONE: Self = ($($name::ONE,)+); } }; }  tuple_one_impl!(A B); }  #[macro_use] mod macros { #[macro_export] macro_rules! fscanln { ($reader:expr, $($i:expr), +) => {{ #[allow(unused_imports)] use std::io::BufRead; let mut iter = std::iter::repeat_with(|| { let mut buf = String::new(); $reader.read_line(&mut buf).unwrap(); buf.split_whitespace() .map(|x| x.to_string()) .collect::<Vec<_>>() }) .flatten(); $( $i = iter.next().unwrap().parse().unwrap(); )* }};  ( $reader:expr, $($i:expr), +, ?) => {{ #[allow(unused_imports)] use std::io::BufRead; let mut iter = std::iter::repeat_with(|| { let mut buf = String::new(); $reader.read_line(&mut buf).unwrap(); buf.split_whitespace() .map(|x| x.to_string()) .collect::<Vec<_>>() }) .find(|x| !x.is_empty()) .unwrap() .into_iter(); $( if let Some(val) = iter.next() { $i = val.parse().unwrap(); } else { $i = Default::default(); } )* }};  ($reader:expr, $coll:expr ; $n:expr) => {{ #[allow(unused_imports)] use std::io::BufRead; $coll = std::iter::once(Default::default()) .chain( std::iter::repeat_with(|| { let mut buf = String::new(); $reader.read_line(&mut buf).unwrap(); buf.split_whitespace() .map(|x| x.parse().unwrap()) .collect::<Vec<_>>() }) .flatten() .take($n), ) .collect(); }};  ($reader:expr, $coll:expr ;) => {{ #[allow(unused_imports)] use std::io::BufRead; let mut buf = String::new(); $reader.read_line(&mut buf).unwrap(); $coll = std::iter::once(Default::default()) .chain(buf.split_whitespace().map(|x| x.parse().unwrap())) .collect(); }}; }  #[macro_export] macro_rules! scanln { ($($i:expr), +) => { $crate::fscanln!(std::io::stdin(), $($i), +); };  ($($i:expr), +, ?) => { $crate::fscanln!(std::io::stdin(), $($i), +, ?); };  ($coll:expr ; $n:expr) => { $crate::fscanln!(std::io::stdin(), $coll ; $n); };  ($coll:expr ;) => { $crate::fscanln!(std::io::stdin(), $coll ;); }; } } }

