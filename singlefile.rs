pub mod cplit { pub mod data_structure { pub mod disjoint_set_union {  #[derive(Debug)] pub struct DisjointSetUnion { fa: Vec<usize>, }  impl DisjointSetUnion { pub fn new(n: usize) -> Self { let fa = (0..=n).collect(); DisjointSetUnion { fa } }  pub fn find(&mut self, x: usize) -> usize { if self.fa[x] == x { x } else { self.fa[x] = self.find(self.fa[x]); self.fa[x] } }  pub fn join(&mut self, x: usize, y: usize) { let fx = self.find(x); self.fa[fx] = self.find(y); } } } pub mod segment_tree { #[derive(Debug)] pub struct SegmentTree { sum: Vec<i64>, tag: Vec<i64>, }  impl SegmentTree { pub fn new(n: usize) -> Self { Self { sum: vec![0; n<<2], tag: vec![0; n<<2], } }  fn pushup(&mut self, x: usize) { let SegmentTree { sum, .. } = self; sum[x] = sum[x<<1] + sum[x<<1|1]; }  fn pushdown(&mut self, x: usize, l: usize, r: usize) { let SegmentTree { sum, tag } = self; let m = (l+r)>>1; sum[x<<1] += tag[x]*(m-l+1) as i64; tag[x<<1] += tag[x]; sum[x<<1|1] += tag[x]*(r-m) as i64; tag[x<<1|1] += tag[x]; tag[x] = 0; }  pub fn build(&mut self, x: usize, l: usize, r: usize, a: &Vec<i64>) { let SegmentTree { sum, .. } = self; if l == r { sum[x] = a[l-1] } else { let m = (l+r)>>1; self.build(x<<1, l, m, a); self.build(x<<1|1, m+1, r, a); self.pushup(x); } }  pub fn modify(&mut self, x: usize, l: usize, r: usize, ql: usize, qr: usize, del: i64) { if ql <= l && r <= qr { let SegmentTree { sum, tag } = self; sum[x] += del*(r-l+1) as i64; tag[x] += del; } else { self.pushdown(x, l, r); let m = (l+r)>>1; if ql <= m { self.modify(x<<1, l, m, ql, qr, del) } if m < qr { self.modify(x<<1|1, m+1, r, ql, qr, del) } self.pushup(x); } }  pub fn query(&mut self, x: usize, l: usize, r: usize, ql: usize, qr: usize) -> i64 { if ql <= l && r <= qr { self.sum[x] } else { self.pushdown(x, l, r); let m = (l+r)>>1; (if ql <= m { self.query(x<<1, l, m, ql, qr) } else { 0 }) + (if m < qr { self.query(x<<1|1, m+1, r, ql, qr) } else { 0 }) } } } } pub mod binary_indexed_tree { #[derive(Debug)] pub struct BinaryIndexedTree { b: Vec<isize>, n: usize, }  impl BinaryIndexedTree { pub fn new(n: usize) -> Self { Self { b: vec![0; n+1], n } }  fn lowbit(x: usize) -> usize { x & (!x + 1) }  pub fn change(&mut self, mut x: usize, y: isize) { let BinaryIndexedTree { b, n } = self; while x <= *n { b[x] += y; x += Self::lowbit(x); } }  pub fn sum(&self, mut x: usize) -> isize { let BinaryIndexedTree { b, .. } = &self; let mut s: isize = 0; while x > 0 { s += b[x]; x -= Self::lowbit(x); } s }  pub fn build(&mut self, a: &Vec<isize>) { let BinaryIndexedTree { b, n } = self; for i in 1..=*n { b[i] = a[i-1]; } let mut x = 1; while x << 1 <= *n { for i in (x..=*n-x).step_by(x << 1) { b[i+x] += b[i]; } x <<= 1; } } } }  #[doc(inline)] pub use self::disjoint_set_union::DisjointSetUnion; #[doc(inline)] pub use self::segment_tree::SegmentTree; #[doc(inline)] pub use self::binary_indexed_tree::BinaryIndexedTree; } mod io { #[macro_use] mod macros { #[macro_export] macro_rules! scanln { ($($i:expr), +) => { let mut iter = std::iter::repeat_with(|| { let mut buf = String::new(); std::io::stdin().read_line(&mut buf).unwrap(); buf.split_whitespace() .map(|x| x.parse().unwrap()) .collect::<Vec<_>>() }) .flatten(); $( $i = iter.next().unwrap(); )* };  ($coll:expr ; $n:expr) => { $coll = std::iter::once(Default::default()) .chain( std::iter::repeat_with(|| { let mut buf = String::new(); std::io::stdin().read_line(&mut buf).unwrap(); buf.split_whitespace() .map(|x| x.parse().unwrap()) .collect::<Vec<_>>() }) .flatten() .take($n), ) .collect(); };  ($coll:expr ;) => { let mut buf = String::new(); std::io::stdin().read_line(&mut buf).unwrap(); $coll = std::iter::once(Default::default()) .chain(buf.split_whitespace().map(|x| x.parse().unwrap())) .collect(); }; } } } }

